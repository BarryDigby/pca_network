table(meta$bcr_status)
taylor = readRDS("/data/github/pca_network/data/Taylor_eSet.RDS")
mat = taylor@assayData$exprs
meta = taylor@phenoData@data
meta = meta[which(!is.na(meta$bcr_status)),]
meta = meta[which(meta$sample_type!="Metastasis"),]
mat = as.data.frame(mat[,rownames(meta)])
meta$days_to_follow_up = floor(meta$time_to_bcr*30.44)
table(meta$bcr_status)
104 + 27
dkfz = readRDS("/data/github/pca_network/data/DKFZ_eSet.RDS")
mat = dkfz@assayData$exprs
meta = dkfz@phenoData@data
meta = meta[which(!is.na(meta$bcr_status)),]
mat = as.data.frame(mat[,rownames(meta)])
meta$days_to_follow_up = floor(meta$time_to_bcr*30.44)
table(meta$bcr_status)
81+24
stockholm = readRDS("/data/github/pca_network/data/Stockholm_eSet.RDS")
mat = stockholm@assayData$exprs
meta = stockholm@phenoData@data
meta = meta[which(!is.na(meta$bcr_status)),]
meta$days_to_follow_up = floor(meta$time_to_bcr*30.44)
# remove NA entry
meta = meta[which(!is.na(meta$days_to_follow_up)),]
mat = as.data.frame(mat[,rownames(meta)])
table(meta$bcr_status)
47 + 45
library(tidyr)
library(dplyr)
library(survival)
library(RegParallel)
library(survminer)
library(timeROC)
library(ggplot2)
library(glmnet)
library(mfp)
library(boot)
#########################################################################
# load ceRNA network genes
#########################################################################
network = read.csv("/data/github/pca_network/results/circ_mirna_mrna_network.txt", header=T, sep="\t")
genes = unique(network$mrna)
#########################################################################
# load TCGA metadata from Protein Atlas.
# Supplement additional metadata from other sources
##########################################################################
atlas_meta = read.csv("/data/github/pca_network/data/tcga_updated_meta.csv", header=T, sep=",")
rownames(atlas_meta) = atlas_meta$sample
# merge BCR status using PCa DB dataset
pca_db = readRDS("/data/github/pca_network/data/TCGA-PRAD_eSet.RDS")
pca_db = pca_db@phenoData@data
pca_db = pca_db[,c(1,27)]
pca_db$sample_id = paste(pca_db$sample_id, "A", sep="")
table(atlas_meta$Row.names %in% pca_db$sample_id)
# 478 matching PCa DB <-> atlas meta. this is better than 464 valid TCGA eset time to event.
atlas_meta = merge(atlas_meta, pca_db, by.x="Row.names", by.y="sample_id")
keep = atlas_meta$sample_type=="Primary Tumor"
atlas_meta = atlas_meta[keep,]
# add Resectional status
# R0 no residual, R1 micro, R2 macro, RX uncertain.
resec = read.csv("/data/github/pca_network/data/prad_tcga_clinical_data.tsv", header=T, sep="\t")
resec$Sample.ID = paste(resec$Sample.ID, "A", sep="")
table(resec$Sample.ID %in% atlas_meta$sample)
atlas_meta = merge(atlas_meta, subset(resec, select=c(Sample.ID, Surgical.Margin.Resection.Status)), by.x="sample", by.y="Sample.ID")
atlas_meta$years_to_follow_up <- as.character(floor(atlas_meta$years_to_follow_up))
#########################################################################
# Use logcpm STAR counts for CoxPH/Kaplan Meier
#########################################################################
logcpm = read.csv("/data/github/pca_network/results/TCGA_mrna_logcpm.txt", header=T, row.names = 1, sep="\t")
colnames(logcpm) = gsub("\\.", "-", colnames(logcpm))
mrna_attributes = read.csv("/data/github/pca_network/results/TCGA_mrna_attributes.txt", header=T, sep="\t")
mrna_attributes = mrna_attributes[which(mrna_attributes$external_gene_name %in% genes),]
logcpm = merge(logcpm, mrna_attributes[,1:2], by.x=0, by.y="ensembl_gene_id_version")
logcpm = tibble::column_to_rownames(logcpm, "external_gene_name")
logcpm = logcpm[,c(2:ncol(logcpm))]
logcpm = logcpm[,atlas_meta$Row.names]
#########################################################################
# Univariate Cox proportional hazards regression:
# Find ceRNA mRNAs * with prognosis of PCa (disease free survival)
#########################################################################
univ_mat = as.data.frame(t(scale(t(logcpm), scale = T, center = T)))
univ_mat = as.data.frame(t(univ_mat))
univ_mat = cbind(univ_mat, atlas_meta[,c("days_to_follow_up", "bcr_status")])
res <- RegParallel(
data = univ_mat,
formula = 'Surv(days_to_follow_up, bcr_status) ~ [*]',
FUN = function(formula, data)
coxph(formula = formula,
data = data,
ties = 'breslow',
singular.ok = TRUE),
FUNtype = 'coxph',
variables = colnames(univ_mat)[1:256],
blocksize = 50,
p.adjust = "BH",
cores = 2,
nestedParallel = FALSE,
conflevel = 95)
res <- res[!is.na(res$P),]
res = res[which(res$P.adjust <= 0.05),]
genes = res$Variable
##########################################################################
# Schoenfelds test - remove genes that violate Coxph assumptions
##########################################################################
univ_mat = univ_mat[,c(genes, "days_to_follow_up", "bcr_status")]
mult_cx = coxph(Surv(days_to_follow_up, bcr_status) ~  ., data=univ_mat)
test.cp = cox.zph(mult_cx, transform = "km")
test.cp
remove = rownames(test.cp$table)[which(test.cp$table[,"p"] <= 0.05)]
# save for plot
sec31b = ggcoxzph2(test.cp)[2]
slc22a3 = ggcoxzph2(test.cp)[12]
genes = setdiff(genes, remove)
univ_mat = univ_mat[,c(genes, "days_to_follow_up", "bcr_status")]
mult_cx = coxph(Surv(days_to_follow_up, bcr_status) ~  ., data=univ_mat)
test.cp = cox.zph(mult_cx)
test.cp
remove = rownames(test.cp$table)[which(test.cp$table[,"p"] <= 0.05)]
srrd = ggcoxzph2(test.cp)[2]
gad1 = ggcoxzph2(test.cp)[8]
genes = setdiff(genes, remove)
univ_mat = univ_mat[,c(genes, "days_to_follow_up", "bcr_status")]
mult_cx = coxph(Surv(days_to_follow_up, bcr_status) ~  ., data=univ_mat)
test.cp = cox.zph(mult_cx)
test.cp
##########################################################################
# Plot hazard ratios
##########################################################################
univ_formulas <- sapply(genes, function(x) as.formula(paste('Surv(days_to_follow_up, bcr_status)~', x)))
univ_models <- lapply(univ_formulas, function(x){coxph(x, data = univ_mat)})
#pdf("/data/github/pca_network/results/TCGA_DFS3/univariate_forest_model.pdf", width=8, height=5)
forestmodel::forest_model(model_list = univ_models,covariates = genes,merge_models =T)
##########################################################################
# Cox ph multiple regression
##########################################################################
set.seed(123)
mult_cox = coxph(Surv(days_to_follow_up, bcr_status) ~., data=univ_mat)
summary(mult_cox)
step = stepAIC(mult_cox, direction = "both")
summary(step)
forestmodel::forest_model(coxph(Surv(days_to_follow_up, bcr_status) ~ REG4 + SLC2A4 + JAG2 + CTHRC1, data=univ_mat))
forestmodel::forest_model(coxph(Surv(days_to_follow_up, bcr_status) ~ REG4 + SLC2A4 + JAG2 + CTHRC1 + PAPSS1 + TRIM13 + INPP5E, data=univ_mat))
forestmodel::forest_model(coxph(Surv(days_to_follow_up, bcr_status) ~ REG4 + SLC2A4 + PAPSS1 + TRIM13 + INPP5E + JAG2 + CTHRC1, data=univ_mat))
final_model = coxph(Surv(days_to_follow_up, bcr_status) ~ REG4 + SLC2A4 + JAG2 + CTHRC1, data=univ_mat)
summary(final_model)
risk_scores = predict(final_model, newdata = univ_mat, type="lp")
View(univ_mat)
head(predict(final_model, newdata = univ_mat[,c("REG4", "SLC2A4", "CTHRC1", "JAG2")], type="lp"))
hist(risk_scores)
vline(median(risk_scores))
abline(v=median(risk_scores))
hist(risk_scores)
hist(risk_scores, col="skyblue", main = "Prognostic Index")
mean(risk_scores)
median(risk_scores)
##########################################################################
# Stratify patients
##########################################################################
cox = as.data.frame(univ_mat[,genes])
cox$risk_score = risk_scores
cox = cbind(cox, atlas_meta[,c("days_to_follow_up", "bcr_status")])
cox$risk_category = ifelse(cox$risk_score >= median(cox$risk_score), "High risk", "Low risk")
surv_object <- Surv(cox$days_to_follow_up, cox$bcr_status)
res2 = survfit(surv_object ~ risk_category, data=cox)
##########################################################################
# Heatmap, scatterplots
##########################################################################
os_mat = cox
os_mat = os_mat[order(os_mat$risk_score, decreasing = F),]
os_mat$patients_inc_risk = seq(1,nrow(os_mat),1)
os_mat$status = factor(os_mat$bcr_status)
os_mat$years = atlas_meta$years_to_follow_up
ggscatter(os_mat, y="risk_score", x="patients_inc_risk", color="risk_category", fill="risk_category",
ylab="Prognostic index", xlab = NULL, palette = c("red","royalblue3"), ggtheme = theme_bw(), size = 1) +
geom_vline(xintercept = mean(os_mat$patients_inc_risk), linetype = "dashed", color = "grey10" ) +
geom_hline(yintercept = mean(os_mat$risk_score), linetype="dashed", color="grey10")
hist(risk_scores, col="skyblue", main = "Prognostic Index")
ggpubr::ggscatter(os_mat %>% dplyr::arrange(status), x="patients_inc_risk", y="days_to_follow_up", shape="status", ylab = "Time (days)",
color="status", fill="status", palette = c("royalblue3","red"), ggtheme = theme_bw()) +
geom_vline(xintercept = mean(os_mat$patients_inc_risk), linetype = "dashed", color = "grey10" )
library(dplyr)
library(ggplot2)
library(tidyr)
library(survminer)
library(survival)
library(rms)
library(survivalAnalysis)
library(pROC)
library(survivalROC)
library(ggpubr)
library(gtsummary)
library(RColorBrewer)
#########################################################################
# load model from previous script.
#########################################################################
load("/data/github/pca_network/results/TCGA_DFS/model.RData")
#########################################################################
# Load cleaned tcga meta, make sure resectional status is included
#########################################################################
load("/data/github/pca_network/data/TCGA_meta_cleaned.RData")
resec = read.csv("/data/github/pca_network/data/prad_tcga_clinical_data.tsv", header=T, sep="\t")
resec$Sample.ID = paste(resec$Sample.ID, "A", sep="")
table(resec$Sample.ID %in% master$Row.names)
master = merge(master, subset(resec, select=c(Sample.ID, Surgical.Margin.Resection.Status)), by.x="Row.names", by.y="Sample.ID")
#########################################################################
# Construct dataframe for analysis
# Tidy/create categoricals for analysis
#########################################################################
mat = master
table(meta$clinical_m_stage)
table(mat$clinical_m_stage)
table(mat$ajcc_pathologic_t)
table(mat$ajcc_pathologic_n)
table(mat$ajcc_clinical_m)
table(mat$Surgical.Margin.Resection.Status)
library(dplyr)
library(ggplot2)
library(tidyr)
library(survminer)
library(survival)
library(rms)
library(survivalAnalysis)
library(pROC)
library(survivalROC)
library(ggpubr)
library(gtsummary)
library(RColorBrewer)
#########################################################################
# load model from previous script.
#########################################################################
load("/data/github/pca_network/results/TCGA_DFS/model.RData")
#########################################################################
# Load cleaned tcga meta, make sure resectional status is included
#########################################################################
load("/data/github/pca_network/data/TCGA_meta_cleaned.RData")
resec = read.csv("/data/github/pca_network/data/prad_tcga_clinical_data.tsv", header=T, sep="\t")
resec$Sample.ID = paste(resec$Sample.ID, "A", sep="")
table(resec$Sample.ID %in% master$Row.names)
master = merge(master, subset(resec, select=c(Sample.ID, Surgical.Margin.Resection.Status)), by.x="Row.names", by.y="Sample.ID")
#########################################################################
# Construct dataframe for analysis
# Tidy/create categoricals for analysis
#########################################################################
mat = master
age_cut = survminer::surv_cutpoint(mat, time="days_to_follow_up", event="bcr_status", variables="age")
mat$age = ifelse(mat$age >= age_cut$cutpoint$cutpoint, ">56", "<56")
mat = tibble::column_to_rownames(mat, "Row.names")
mat$psa <- ifelse(mat$preop_psa > 20, ">20ng/ml",
ifelse(mat$preop_psa >= 10 & mat$preop_psa <= 20, "10-20ng/ml", "<10ng/ml"))
mat$path_t = ifelse(mat$ajcc_pathologic_t == "T2a" | mat$ajcc_pathologic_t == "T2b" | mat$ajcc_pathologic_t == "T2c", "T2", mat$ajcc_pathologic_t)
mat$path_t = ifelse(mat$ajcc_pathologic_t == "T3a" | mat$ajcc_pathologic_t == "T3b", "T3", mat$path_t)
mat$clin_m = ifelse(mat$ajcc_clinical_m == "M0", "M0", "M1")
mat$path_n = ifelse(mat$ajcc_pathologic_n == "N1", "N1","N0")
mat$gleason = ifelse(mat$gleason_score == 6, "Gleason 6 or lower", mat$gleason_score)
mat$gleason = ifelse(mat$gleason_score == 7, "Gleason 7", mat$gleason)
mat$gleason = ifelse(mat$gleason_score > 7, "Gleason 8,9,10", mat$gleason)
mat$surgical_r = ifelse(mat$Surgical.Margin.Resection.Status == "R2" | mat$Surgical.Margin.Resection.Status == "R1",  "R1/R2", mat$Surgical.Margin.Resection.Status)
w <- transcan(~ age + gleason + psa + path_t + path_n + clin_m +
surgical_r, imputed=TRUE, data=mat, pl=TRUE, pr=FALSE)
attach(mat)
mat2 = mat
psa = impute(w, psa, data=mat)
levels(factor(mat$psa))
mat2$psa = ifelse(psa == 1, "<10ng/ml",
ifelse(psa == 3, "10-20ng/ml",
ifelse(psa == 2, ">20ng/ml", psa)))
path_t = impute(w, path_t, data = mat)
levels(factor(mat$path_t))
mat2$path_t = ifelse(path_t == 1, "T2",
ifelse(path_t == 2, "T3",
ifelse(path_t == 3, "T4", path_t)))
path_n = impute(w, path_n, data=mat)
levels(factor(mat$path_n))
mat2$path_n = ifelse(path_n == 1, "N0",
ifelse(path_n == 2, "N1", path_n))
clin_m = impute(w, clin_m, data=mat)
levels(factor(mat$clin_m))
mat2$clin_m = ifelse(clin_m == 1, "M0", clin_m)
surgical_r = impute(w, surgical_r, data=mat)
levels(factor(mat$surgical_r))
mat2$surgical_r = ifelse(surgical_r==1, "R0",
ifelse(surgical_r == 2, "R1/R2",
ifelse(surgical_r == 3 , "RX", surgical_r)))
mat2$risk_score = risk_scores
## univariate forest plot
vars_for_table = c("age","psa", "gleason", "path_t", "path_n", "clin_m", "surgical_r", "risk_score")
univ_formulas <- sapply(vars_for_table, function(x) as.formula(paste('Surv(days_to_follow_up, bcr_status)~', x)))
univ_models <- lapply(univ_formulas, function(x){coxph(x, data = mat2)})
forestmodel::forest_model(model_list = univ_models,covariates = vars_for_table,merge_models =T)
#pdf("/data/github/pca_network/results/TCGA_DFS3/univariate_forest_model.pdf", width=8, height=5)
forestmodel::forest_model(model_list = univ_models,covariates = vars_for_table,merge_models =T)
forestmodel::forest_model(coxph(Surv(days_to_follow_up, bcr_status) ~ age + psa + gleason +  path_t + path_n + clin_m + surgical_r + risk_score, data=mat2))
clin_mod = coxph(Surv(days_to_follow_up, bcr_status) ~ age + path_t + surgical_r + risk_score, data=mat2)
# Harrell's C
rcorr.cens(-1*mat2$risk_score, Surv(mat2$days_to_follow_up, mat2$bcr_status))[1]
regplot::regplot(clin_mod, failtime = c(365,1095,1826, 3650), points = T, odds = FALSE, nsamp = 481, title = "")
# save for plot
sec31b = ggcoxzph2(test.cp)[2]
sec31b
genes = res$Variable
##########################################################################
# Schoenfelds test - remove genes that violate Coxph assumptions
##########################################################################
univ_mat = univ_mat[,c(genes, "days_to_follow_up", "bcr_status")]
mult_cx = coxph(Surv(days_to_follow_up, bcr_status) ~  ., data=univ_mat)
test.cp = cox.zph(mult_cx, transform = "km")
test.cp
remove = rownames(test.cp$table)[which(test.cp$table[,"p"] <= 0.05)]
# save for plot
sec31b = ggcoxzph2(test.cp)[2]
sec31b
ggcoxzph2(test.cp)[1]
ggcoxzph2(test.cp)[3]
ggcoxzph2(test.cp)[4]
ggcoxzph2(test.cp)[5]
ggcoxzph2(test.cp)[6]
ggcoxzph2(test.cp)[7]
ggcoxzph2(test.cp)[8]
ggcoxzph2(test.cp)[9]
ggcoxzph2(test.cp)[10]
##########################################################################
# Schoenfelds test - remove genes that violate Coxph assumptions
##########################################################################
univ_mat = univ_mat[,c(genes, "days_to_follow_up", "bcr_status")]
mult_cx = coxph(Surv(days_to_follow_up, bcr_status) ~  ., data=univ_mat)
test.cp = cox.zph(mult_cx, transform = "km")
test.cp
# save for plot
sec31b = ggcoxzph2(test.cp)[2]
sec31b
##########################################################################
# Schoenfelds test - remove genes that violate Coxph assumptions
##########################################################################
univ_mat = univ_mat[,c(genes, "days_to_follow_up", "bcr_status")]
mult_cx = coxph(Surv(days_to_follow_up, bcr_status) ~  ., data=univ_mat)
test.cp = cox.zph(mult_cx, transform = "km")
test.cp
#remove = rownames(test.cp$table)[which(test.cp$table[,"p"] <= 0.05)]
# save for plot
sec31b = ggcoxzph2(test.cp)[2]
sec31b
#########################################################################
# Univariate Cox proportional hazards regression:
# Find ceRNA mRNAs * with prognosis of PCa (disease free survival)
#########################################################################
univ_mat = as.data.frame(t(scale(t(logcpm), scale = T, center = T)))
univ_mat = as.data.frame(t(univ_mat))
univ_mat = cbind(univ_mat, atlas_meta[,c("days_to_follow_up", "bcr_status")])
res <- RegParallel(
data = univ_mat,
formula = 'Surv(days_to_follow_up, bcr_status) ~ [*]',
FUN = function(formula, data)
coxph(formula = formula,
data = data,
ties = 'breslow',
singular.ok = TRUE),
FUNtype = 'coxph',
variables = colnames(univ_mat)[1:256],
blocksize = 50,
p.adjust = "BH",
cores = 2,
nestedParallel = FALSE,
conflevel = 95)
res <- res[!is.na(res$P),]
res = res[which(res$P.adjust <= 0.05),]
genes = res$Variable
##########################################################################
# Schoenfelds test - remove genes that violate Coxph assumptions
##########################################################################
univ_mat = univ_mat[,c(genes, "days_to_follow_up", "bcr_status")]
mult_cx = coxph(Surv(days_to_follow_up, bcr_status) ~  ., data=univ_mat)
test.cp = cox.zph(mult_cx, transform = "km")
test.cp
#remove = rownames(test.cp$table)[which(test.cp$table[,"p"] <= 0.05)]
# save for plot
sec31b = ggcoxzph2(test.cp)[2]
sec31b
#remove = rownames(test.cp$table)[which(test.cp$table[,"p"] <= 0.05)]
# save foggcoxzph2(test.cp)[12]
ggcoxzph2(test.cp)[12]
ggcoxzph2(test.cp)[22]
ggcoxzph2(test.cp)[2]
ggcoxzph2(test.cp)[4]
ggcoxzph2(test.cp)[5]
#########################################################################
# Univariate Cox proportional hazards regression:
# Find ceRNA mRNAs * with prognosis of PCa (disease free survival)
#########################################################################
univ_mat = as.data.frame(t(scale(t(logcpm), scale = T, center = T)))
univ_mat = as.data.frame(t(univ_mat))
univ_mat = cbind(univ_mat, atlas_meta[,c("days_to_follow_up", "bcr_status")])
res <- RegParallel(
data = univ_mat,
formula = 'Surv(days_to_follow_up, bcr_status) ~ [*]',
FUN = function(formula, data)
coxph(formula = formula,
data = data,
ties = 'breslow',
singular.ok = TRUE),
FUNtype = 'coxph',
variables = colnames(univ_mat)[1:256],
blocksize = 50,
p.adjust = "BH",
cores = 2,
nestedParallel = FALSE,
conflevel = 95)
res <- res[!is.na(res$P),]
res = res[which(res$P.adjust <= 0.05),]
genes = res$Variable
##########################################################################
# Schoenfelds test - remove genes that violate Coxph assumptions
##########################################################################
univ_mat = univ_mat[,c(genes, "days_to_follow_up", "bcr_status")]
mult_cx = coxph(Surv(days_to_follow_up, bcr_status) ~  ., data=univ_mat)
test.cp = cox.zph(mult_cx, transform = "km")
test.cp
#remove = rownames(test.cp$table)[which(test.cp$table[,"p"] <= 0.05)]
# save for plot
sec31b = ggcoxzph2(test.cp)[2]
remove = rownames(test.cp$table)[which(test.cp$table[,"p"] <= 0.05)]
genes = setdiff(genes, remove)
univ_mat = univ_mat[,c(genes, "days_to_follow_up", "bcr_status")]
mult_cx = coxph(Surv(days_to_follow_up, bcr_status) ~  ., data=univ_mat)
test.cp = cox.zph(mult_cx)
test.cp
remove = rownames(test.cp$table)[which(test.cp$table[,"p"] <= 0.05)]
srrd = ggcoxzph2(test.cp)[2]
gad1 = ggcoxzph2(test.cp)[8]
genes = setdiff(genes, remove)
univ_mat = univ_mat[,c(genes, "days_to_follow_up", "bcr_status")]
mult_cx = coxph(Surv(days_to_follow_up, bcr_status) ~  ., data=univ_mat)
test.cp = cox.zph(mult_cx)
test.cp
##########################################################################
# Plot hazard ratios
##########################################################################
univ_formulas <- sapply(genes, function(x) as.formula(paste('Surv(days_to_follow_up, bcr_status)~', x)))
univ_models <- lapply(univ_formulas, function(x){coxph(x, data = univ_mat)})
#pdf("/data/github/pca_network/results/TCGA_DFS3/univariate_forest_model.pdf", width=8, height=5)
forestmodel::forest_model(model_list = univ_models,covariates = genes,merge_models =T)
##########################################################################
# Cox ph multiple regression
##########################################################################
set.seed(123)
mult_cox = coxph(Surv(days_to_follow_up, bcr_status) ~., data=univ_mat)
summary(mult_cox)
step = stepAIC(mult_cox, direction = "both")
forestmodel::forest_model(coxph(Surv(days_to_follow_up, bcr_status) ~ REG4 + SLC2A4 + PAPSS1 + TRIM13 + INPP5E + JAG2 + CTHRC1, data=univ_mat))
library(survival)
library(sjPlot)
library(survminer)
library(timeROC)
library(ggpubr)
library(rms)
library(survAUC)
library(pec)
load("/data/github/pca_network/results/TCGA_DFS/model.RData")
# Belfast dataset
belfast_rds = readRDS("/data/github/pca_network/data/Belfast_eSet.RDS")
mat = belfast_rds@assayData$exprs
meta = belfast_rds@phenoData@data
meta$days_to_follow_up = meta$time_to_bcr * 30.44
rm(belfast_rds)
mrna_attributes = read.csv("/data/github/pca_network/results/TCGA_mrna_attributes.txt", header=T, sep="\t")
mrna_attributes = mrna_attributes[which(mrna_attributes$external_gene_name %in% genes),]
mat = merge(mat, mrna_attributes[,c(1,3)], by.x=0, by.y="ensembl_gene_id")
mat = tibble::column_to_rownames(mat, "external_gene_name")
mat = mat[,2:ncol(mat)]
mat = as.data.frame(t(mat))
mat = as.data.frame(scale(mat, scale = T, center = T))
belfast_risk = predict(final_model, newdata = mat, type="lp")
sub_meta = subset(meta, select=c(days_to_follow_up, bcr_status))
mat = cbind(mat, sub_meta)
# Method 1: Regression on PI in validation data
# create new variables to match worked example:
fit_dev = final_model
df_dev = cox
Xb_dev <- model.matrix(fit_dev) %*% coef(fit_dev)
Xbavg_dev <- sum(coef(fit_dev)*fit_dev$means)
PI_dev <- Xb_dev - Xbavg_dev # centered PI in development dataset (for discrimination later)
df_dev$PI_dev <- PI_dev
df_val <- mat
# fit model in validation data
fit_val <- coxph(Surv(days_to_follow_up, bcr_status) ~  REG4 + SLC2A4 + CTHRC1 + JAG2, data=df_val)
Xb_val <- model.matrix(fit_val) %*% coef(fit_dev) # determine Xb in validation data
PI_val <- Xb_val - Xbavg_dev # center PI by using mean of PI of development data
df_val$PI_val <- PI_val
fit_val <- coxph(Surv(days_to_follow_up, bcr_status) ~ PI_val, data=df_val)
tab_model(fit_val, transform=NULL, show.r2 = FALSE)
fit_val_test <- coxph(Surv(days_to_follow_up, bcr_status) ~ PI_val + offset(PI_val), data=df_val)
tab_model(fit_val_test, transform=NULL, show.r2 = FALSE)
tab_model(fit_val, transform=NULL, show.r2 = FALSE)
tab_model(fit_val_test, transform=NULL, show.r2 = FALSE)
# Method 2: Check model misspecification/fit
# offset = set PI to 1 i,e ike fit_dev
fit_val <- coxph(Surv(days_to_follow_up, bcr_status) ~ REG4 + SLC2A4 + CTHRC1 + JAG2 + offset(PI_val), data=df_val)
round(2*(diff(fit_val$loglik)), 2) # Chi-squared value
round(1-pchisq(2*(diff(fit_val$loglik)), 8), 3) # p-value
summary(fit_val)
round(2*(diff(fit_val$loglik)), 2) # Chi-squared value
fit_val$loglik
gset <- getGEO("GSE1159", GSEMatrix =TRUE, getGPL=FALSE)
library(GEOquery)
gset <- getGEO("GSE1159", GSEMatrix =TRUE, getGPL=FALSE)
if (length(gset) > 1) idx <- grep("GPL570", attr(gset, "names")) else idx <- 1
gset <- gset[[idx]]
info = pData(gset)
View(info)
e = eset(gset)
e = ExpressionSet(gset)
View(gset)
